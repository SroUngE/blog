---
title: "Interview MySQL"
date: 2024-02-06T22:50:17+08:00
draft: false
tags: ["MySQL"]
featuredImage: "https://s2.loli.net/2024/01/23/FdJWU6IpNZGfACv.png"
featuredImagePreview: "https://s2.loli.net/2024/01/23/FdJWU6IpNZGfACv.png"
---



### MySQL 的数据类型

MySQL支持多种数据类型，包括但不限于：

1. **整数类型：**
   - `INT`（整数）
   - `BIGINT`（大整数）
   - `TINYINT`（小整数）
2. **浮点数类型：**
   - `FLOAT`（单精度浮点数）
   - `DOUBLE`（双精度浮点数）
3. **定点数类型：**
   - `DECIMAL`（用于存储精确小数）
4. **日期与时间类型：**
   - `DATE`（日期）
   - `TIME`（时间）
   - `DATETIME`（日期与时间的组合）
   - `TIMESTAMP`（时间戳）
5. **字符串类型：**
   - `CHAR`（固定长度字符串）
   - `VARCHAR`（可变长度字符串）
   - `TEXT`（文本）
6. **二进制数据类型：**
   - `BLOB`（二进制大对象，用于存储二进制数据）
7. **枚举与集合类型：**
   - `ENUM`（枚举，存储字符串列表中的一个值）
   - `SET`（集合，存储字符串列表中的多个值）
8. **空间数据类型：**
   - `GEOMETRY`（存储几何图形）

每种数据类型都有其适用的场景和特点，选择合适的数据类型有助于提高数据库性能和数据存储效率。



#### CHAR 和 VARCHAR 的区别

`CHAR` 和 `VARCHAR` 是MySQL中两种不同的字符串类型，它们的主要区别在于存储方式和使用场景：

1. **存储方式：**
   - `CHAR` 是固定长度的字符串类型，无论存储的数据多长，都会占用固定数量的空间。如果存储的字符串长度不足定义的长度，会使用空格进行填充。
   - `VARCHAR` 是可变长度的字符串类型，它只占用实际存储的数据长度加上一些额外的字节来记录长度信息。这使得 `VARCHAR` 更加灵活，能够节省存储空间。

2. **使用场景：**
   - 使用 `CHAR` 适合存储长度固定的数据，比如存储固定长度的代码或标识符。
   - 使用 `VARCHAR` 适合存储长度可变的数据，例如描述性文本或变长字符串。

总体而言，如果你知道存储的字符串长度是固定的，可以使用 `CHAR` 以获得更快的检索性能。但如果字符串长度变化较大，可能会浪费空间，此时使用 `VARCHAR` 更为合适。



### MySQL的存储引擎

当然！让我们重点介绍MySQL的前两个存储引擎：

1. **InnoDB（默认存储引擎）:**
   - **事务支持：** InnoDB是MySQL中默认且最广泛使用的存储引擎之一。它提供了事务支持，确保ACID（原子性、一致性、隔离性、持久性）属性。这对于需要可靠和安全数据处理的应用程序至关重要。

   - **行级锁定：** InnoDB采用行级锁定，允许多个事务同时在同一表的不同部分上工作。这增强了并发性并减少了对资源的争夺。

   - **外键约束：** InnoDB支持外键约束，有助于强制执行表之间的引用完整性。这对于维护数据库中的关系一致性非常重要。

   - **崩溃恢复：** InnoDB具有强大的崩溃恢复机制，确保在意外系统故障的情况下也能保持数据的持久性。

2. **MyISAM:**
   - **无事务支持：** MyISAM是较早的存储引擎，不支持事务。它主要使用表级锁定，因此在高并发环境中效果较差。

   - **读优化：** MyISAM非常适合读密集型应用，如数据仓库或数据很少更改的情况。在需要大量读操作而写操作相对较少的场景中表现良好。

   - **全文搜索：** MyISAM内置了全文搜索功能，适用于需要高效文本搜索的应用程序。

   - **表级锁定：** MyISAM使用表级锁定，这意味着在发生写操作时整个表都会被锁定。这可能导致在高并发情况下争夺和性能下降。



### InnoDB 的事务

InnoDB存储引擎具有ACID属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性是数据库管理系统（DBMS）中确保数据可靠性和一致性的基本原则。

1. **原子性（Atomicity）：**
   - **定义：** 事务是一个原子操作单元，要么全部执行成功，要么全部回滚到事务开始前的状态。
   - **实现：** InnoDB通过日志（log）和回滚段（rollback segments）来确保事务的原子性，允许回滚到事务开始之前的状态。

2. **一致性（Consistency）：**
   - **定义：** 在事务开始和结束时，数据库必须保持一致的状态。如果事务执行成功，数据库应该从一个一致的状态转移到另一个一致的状态。
   - **实现：** InnoDB通过执行预定义的一致性检查来确保事务的一致性，例如在事务开始和结束时检查数据完整性。

3. **隔离性（Isolation）：**
   - **定义：** 各个事务的执行应该相互隔离，一个事务的执行不应该影响其他事务的执行。
   - **实现：** InnoDB通过使用多版本并发控制（MVCC）来实现隔离性，每个事务在读取数据时都能够看到一个一致的快照，而不受其他事务的影响。

4. **持久性（Durability）：**
   - **定义：** 一旦事务被提交，其结果应该永久保存在数据库中，即使发生系统故障。
   - **实现：** InnoDB通过将事务的操作记录到事务日志（transaction log）中，并定期将这些日志刷新到磁盘，以确保事务的持久性。

这些ACID属性确保了数据库系统的可靠性和稳定性，使得在面对故障或并发执行时，数据库能够保持一致且可靠的状态。

### InnoDB 的四个实现

1. **插入缓冲（Insert Buffer）：**
   - **特性：** InnoDB使用插入缓冲来优化主键索引的插入操作。
   - **实现：** 当有新记录插入到表中时，InnoDB首先将新记录的主键值插入到插入缓冲中，稍后再按顺序将这些记录合并到主索引中。这有助于减少主索引上的随机I/O操作，提高插入性能。

2. **自适应哈希索引（Adaptive Hash Index）：**
   - **特性：** InnoDB引擎会根据查询模式动态地维护一个自适应哈希索引，以提高某些查询的性能。
   - **实现：** InnoDB监视表中索引的使用情况，对于频繁访问的索引会创建哈希索引以提高查询性能。

3. **双写缓冲（Double Write Buffer）：**
   - **特性：** 用于提高数据页的持久性，减小因为写入页时发生的数据页损坏的风险。
   - **实现：** 在写入磁盘之前，InnoDB首先将数据页写入双写缓冲，然后再写入磁盘。这有助于防止在写入磁盘时因系统崩溃或掉电导致的数据页损坏。

4. **自动增量计数器的互斥插入（Mutex Insert for AUTO_INCREMENT）：**
   - **特性：** InnoDB引入互斥插入，以提高自动增量计数器的并发性能。
   - **实现：** 多个事务插入数据时，InnoDB使用互斥锁确保自动增量计数器的并发安全性，防止出现重复的自动增量值。

### InnoDB 为何推荐用自增主键

自增主键减小插入操作性能开销的原因主要在于数据库引擎对于索引维护（B+树）的方式。当插入一条新记录时，数据库需要确保索引的有序性，以便提高查询性能。使用自增主键时，新记录的主键值会按照递增的顺序生成，这样新记录会被追加到表的末尾。

这追加操作的好处在于：
1. **避免页面分裂：** 数据库以页面（page）为单位进行管理，如果插入记录导致某个页面空间不足，就需要进行页面分裂，调整存储结构，这会导致额外的磁盘IO和性能开销。自增主键的顺序插入可以减小页面分裂的可能性。

2. **提高顺序写性能：** 追加新记录到表末尾的方式，使得写入操作更有序，从而提高磁盘顺序写入性能。这对于磁盘IO效率和日志记录尤其重要。

### InnoDB 的存储结构

InnoDB的存储结构是以页（page）、区（extent）和段（segment）为基础的。这组织层次有助于优化磁盘空间利用和提高访问性能。

1. **页（Page）：** InnoDB以16KB大小的页为基本的存储单元。数据和索引都存储在页中，包括索引、数据行和Undo页等。页是InnoDB管理存储空间的基本单元，也是数据传输的单位。

2. **区（Extent）：** 区是由若干连续页组成的一块空间。InnoDB的区大小可以根据配置进行调整，通常为1MB。当InnoDB需要分配多个连续页时，它会以区为单位进行分配，这有助于减小内部碎片，提高存储效率。

3. **段（Segment）：** 段是一组区的集合，它是表空间的逻辑单位。每个InnoDB表都至少有一个由表的主键索引组成的段。此外，如果表有二级索引，每个二级索引也对应一个段。段的存在有助于对表的不同部分进行独立管理，例如，可以对不同的段采用不同的压缩策略。
