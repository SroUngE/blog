---
title: "Interview MySQL"
date: 2024-02-06T22:50:17+08:00
draft: true
tags: ["MySQL"]
featuredImage: "https://s2.loli.net/2024/01/23/FdJWU6IpNZGfACv.png"
featuredImagePreview: "https://s2.loli.net/2024/01/23/FdJWU6IpNZGfACv.png"
---



### MySQL 的数据类型

MySQL支持多种数据类型，包括但不限于：

1. **整数类型：**
   - `INT`（整数）
   - `BIGINT`（大整数）
   - `TINYINT`（小整数）
2. **浮点数类型：**
   - `FLOAT`（单精度浮点数）
   - `DOUBLE`（双精度浮点数）
3. **定点数类型：**
   - `DECIMAL`（用于存储精确小数）
4. **日期与时间类型：**
   - `DATE`（日期）
   - `TIME`（时间）
   - `DATETIME`（日期与时间的组合）
   - `TIMESTAMP`（时间戳）
5. **字符串类型：**
   - `CHAR`（固定长度字符串）
   - `VARCHAR`（可变长度字符串）
   - `TEXT`（文本）
6. **二进制数据类型：**
   - `BLOB`（二进制大对象，用于存储二进制数据）
7. **枚举与集合类型：**
   - `ENUM`（枚举，存储字符串列表中的一个值）
   - `SET`（集合，存储字符串列表中的多个值）
8. **空间数据类型：**
   - `GEOMETRY`（存储几何图形）

每种数据类型都有其适用的场景和特点，选择合适的数据类型有助于提高数据库性能和数据存储效率。



#### CHAR 和 VARCHAR 的区别

`CHAR` 和 `VARCHAR` 是MySQL中两种不同的字符串类型，它们的主要区别在于存储方式和使用场景：

1. **存储方式：**
   - `CHAR` 是固定长度的字符串类型，无论存储的数据多长，都会占用固定数量的空间。如果存储的字符串长度不足定义的长度，会使用空格进行填充。
   - `VARCHAR` 是可变长度的字符串类型，它只占用实际存储的数据长度加上一些额外的字节来记录长度信息。这使得 `VARCHAR` 更加灵活，能够节省存储空间。

2. **使用场景：**
   - 使用 `CHAR` 适合存储长度固定的数据，比如存储固定长度的代码或标识符。
   - 使用 `VARCHAR` 适合存储长度可变的数据，例如描述性文本或变长字符串。

总体而言，如果你知道存储的字符串长度是固定的，可以使用 `CHAR` 以获得更快的检索性能。但如果字符串长度变化较大，可能会浪费空间，此时使用 `VARCHAR` 更为合适。



### MySQL的存储引擎

当然！让我们重点介绍MySQL的前两个存储引擎：

1. **InnoDB（默认存储引擎）:**
   - **事务支持：** InnoDB是MySQL中默认且最广泛使用的存储引擎之一。它提供了事务支持，确保ACID（原子性、一致性、隔离性、持久性）属性。这对于需要可靠和安全数据处理的应用程序至关重要。

   - **行级锁定：** InnoDB采用行级锁定，允许多个事务同时在同一表的不同部分上工作。这增强了并发性并减少了对资源的争夺。

   - **外键约束：** InnoDB支持外键约束，有助于强制执行表之间的引用完整性。这对于维护数据库中的关系一致性非常重要。

   - **崩溃恢复：** InnoDB具有强大的崩溃恢复机制，确保在意外系统故障的情况下也能保持数据的持久性。

2. **MyISAM:**
   - **无事务支持：** MyISAM是较早的存储引擎，不支持事务。它主要使用表级锁定，因此在高并发环境中效果较差。

   - **读优化：** MyISAM非常适合读密集型应用，如数据仓库或数据很少更改的情况。在需要大量读操作而写操作相对较少的场景中表现良好。

   - **全文搜索：** MyISAM内置了全文搜索功能，适用于需要高效文本搜索的应用程序。

   - **表级锁定：** MyISAM使用表级锁定，这意味着在发生写操作时整个表都会被锁定。这可能导致在高并发情况下争夺和性能下降。



### InnoDB 的事务

InnoDB存储引擎具有ACID属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性是数据库管理系统（DBMS）中确保数据可靠性和一致性的基本原则。

1. **原子性（Atomicity）：**
   - **定义：** 事务是一个原子操作单元，要么全部执行成功，要么全部回滚到事务开始前的状态。
   - **实现：** InnoDB通过日志（log）和回滚段（rollback segments）来确保事务的原子性，允许回滚到事务开始之前的状态。

2. **一致性（Consistency）：**
   - **定义：** 在事务开始和结束时，数据库必须保持一致的状态。如果事务执行成功，数据库应该从一个一致的状态转移到另一个一致的状态。
   - **实现：** InnoDB通过执行预定义的一致性检查来确保事务的一致性，例如在事务开始和结束时检查数据完整性。

3. **隔离性（Isolation）：**
   - **定义：** 各个事务的执行应该相互隔离，一个事务的执行不应该影响其他事务的执行。
   - **实现：** InnoDB通过使用多版本并发控制（MVCC）来实现隔离性，每个事务在读取数据时都能够看到一个一致的快照，而不受其他事务的影响。

4. **持久性（Durability）：**
   - **定义：** 一旦事务被提交，其结果应该永久保存在数据库中，即使发生系统故障。
   - **实现：** InnoDB通过将事务的操作记录到事务日志（transaction log）中，并定期将这些日志刷新到磁盘，以确保事务的持久性。

这些ACID属性确保了数据库系统的可靠性和稳定性，使得在面对故障或并发执行时，数据库能够保持一致且可靠的状态。

### InnoDB 的四个实现

1. **插入缓冲（Insert Buffer）：**
   - **特性：** InnoDB使用插入缓冲来优化主键索引的插入操作。
   - **实现：** 当有新记录插入到表中时，InnoDB首先将新记录的主键值插入到插入缓冲中，稍后再按顺序将这些记录合并到主索引中。这有助于减少主索引上的随机I/O操作，提高插入性能。

2. **自适应哈希索引（Adaptive Hash Index）：**
   - **特性：** InnoDB引擎会根据查询模式动态地维护一个自适应哈希索引，以提高某些查询的性能。
   - **实现：** InnoDB监视表中索引的使用情况，对于频繁访问的索引会创建哈希索引以提高查询性能。

3. **双写缓冲（Double Write Buffer）：**
   - **特性：** 用于提高数据页的持久性，减小因为写入页时发生的数据页损坏的风险。
   - **实现：** 在写入磁盘之前，InnoDB首先将数据页写入双写缓冲，然后再写入磁盘。这有助于防止在写入磁盘时因系统崩溃或掉电导致的数据页损坏。

4. **自动增量计数器的互斥插入（Mutex Insert for AUTO_INCREMENT）：**
   - **特性：** InnoDB引入互斥插入，以提高自动增量计数器的并发性能。
   - **实现：** 多个事务插入数据时，InnoDB使用互斥锁确保自动增量计数器的并发安全性，防止出现重复的自动增量值。

### InnoDB 为何推荐用自增主键

自增主键减小插入操作性能开销的原因主要在于数据库引擎对于索引维护（B+树）的方式。当插入一条新记录时，数据库需要确保索引的有序性，以便提高查询性能。使用自增主键时，新记录的主键值会按照递增的顺序生成，这样新记录会被追加到表的末尾。

这追加操作的好处在于：
1. **避免页面分裂：** 数据库以页面（page）为单位进行管理，如果插入记录导致某个页面空间不足，就需要进行页面分裂，调整存储结构，这会导致额外的磁盘IO和性能开销。自增主键的顺序插入可以减小页面分裂的可能性。

2. **提高顺序写性能：** 追加新记录到表末尾的方式，使得写入操作更有序，从而提高磁盘顺序写入性能。这对于磁盘IO效率和日志记录尤其重要。

### InnoDB 的存储结构

InnoDB的存储结构是以页（page）、区（extent）和段（segment）为基础的。这组织层次有助于优化磁盘空间利用和提高访问性能。

1. **页（Page）：** InnoDB以16KB大小的页为基本的存储单元。数据和索引都存储在页中，包括索引、数据行和Undo页等。页是InnoDB管理存储空间的基本单元，也是数据传输的单位。

2. **区（Extent）：** 区是由若干连续页组成的一块空间。InnoDB的区大小可以根据配置进行调整，通常为1MB。当InnoDB需要分配多个连续页时，它会以区为单位进行分配，这有助于减小内部碎片，提高存储效率。

3. **段（Segment）：** 段是一组区的集合，它是表空间的逻辑单位。每个InnoDB表都至少有一个由表的主键索引组成的段。此外，如果表有二级索引，每个二级索引也对应一个段。段的存在有助于对表的不同部分进行独立管理，例如，可以对不同的段采用不同的压缩策略。



### SQL 优化实践

在SQL语句上的优化是数据库性能调优的重要一环。以下是一些针对SQL语句优化的建议：

#### 1. **使用EXPLAIN分析查询**

`EXPLAIN`关键字可以帮助你理解MySQL如何执行你的SQL语句。通过分析`EXPLAIN`的输出，你可以找到可能的性能瓶颈，如缺少索引、不合适的连接顺序等。

#### 2. **避免SELECT **
只选择需要的列，而不是使用`SELECT *`来选择所有列。这可以减少数据传输的开销，并可能使查询执行计划更加高效。

#### 3. **优化JOIN操作**

* **减少JOIN的数量**：尽量通过子查询或临时表来减少JOIN操作。
* **确保JOIN的字段有索引**：这可以加速JOIN操作。
* **考虑JOIN的顺序**：将结果集较小的表放在前面，这有助于减少中间结果集的大小。

#### 4. **使用索引**

* **创建合适的索引**：确保经常用于搜索、排序和连接的字段都有索引。
* **避免全表扫描**：通过创建索引来减少全表扫描的情况。
* **注意索引的选择性**：选择性高的索引（即索引中不同值的比例高）通常更有效。

#### 5. **优化WHERE子句**

* **避免在WHERE子句中使用函数**：这可能导致索引失效。
* **使用IN代替多个OR**：当需要匹配多个值时，使用`IN`通常比使用多个`OR`更高效。
* **避免使用NOT IN和<>操作符**：这些操作符通常会导致全表扫描。

#### 6. **优化子查询**

* **考虑将子查询改写为JOIN**：有时将子查询转换为JOIN操作可以提高性能。
* **使用EXISTS代替IN**：在某些情况下，`EXISTS`比`IN`更高效。

#### 7. **使用LIMIT限制结果集**
如果只需要部分结果，使用`LIMIT`来限制返回的行数。

#### 8. **优化排序操作**

* **减少排序的数据量**：只排序需要的列，而不是整行数据。
* **确保排序字段有索引**：这可以加速排序操作。

#### 9. **避免在列上进行计算**
在列上进行计算（如加法、乘法等）会导致索引失效，从而降低查询性能。如果可能，尽量在查询之前对数据进行计算和处理。

#### 10. **优化分组操作**

* **减少分组的数据量**：只选择需要的列进行分组。
* **考虑是否真的需要分组**：有时可以通过其他方式（如子查询或临时表）来避免分组操作。

当然可以，关于将子查询改写为JOIN以及减少JOIN的数量，下面我将分别给出具体的例子来说明这两种优化策略。

#### 将子查询改写为JOIN

**子查询示例**：

假设我们有两个表，一个是`orders`（订单表），另一个是`customers`（客户表）。我们想要查询所有下过订单的客户信息。

```sql
SELECT *
FROM customers
WHERE customer_id IN (SELECT DISTINCT customer_id FROM orders);
```

在这个例子中，子查询 `(SELECT DISTINCT customer_id FROM orders)` 首先执行，返回一个客户ID的列表，然后外部查询使用这个列表来从`customers`表中选取对应的记录。

**改写为JOIN**：

将子查询改写为JOIN操作，可以避免子查询可能带来的性能开销，特别是当子查询返回的结果集很大时。

```sql
SELECT DISTINCT c.*
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id;
```

在这个JOIN操作中，我们直接通过`customer_id`将`customers`表和`orders`表连接起来，并获取所有下过订单的客户信息。这种写法通常更高效，因为数据库可以更好地优化JOIN操作。

#### 减少JOIN的数量

**多JOIN示例**：

假设我们有三个表，`orders`（订单表）、`order_details`（订单详情表）和`products`（产品表）。我们想要查询每个订单及其对应的产品信息。

```sql
SELECT o.*, p.*
FROM orders o
JOIN order_details od ON o.order_id = od.order_id
JOIN products p ON od.product_id = p.product_id;
```

在这个例子中，我们使用了两个JOIN操作来连接三个表。虽然这在逻辑上是正确的，但如果我们只需要部分信息或者可以通过其他方式获取所需数据，那么可能可以通过减少JOIN的数量来优化查询。

**使用子查询或临时表减少JOIN**：

例如，如果我们只需要订单信息和与之关联的某个特定产品（例如订单中的第一个产品），我们可以使用子查询来先获取这个产品的信息，然后再与订单表连接。

```sql
SELECT o.*, (
    SELECT p.product_name
    FROM order_details od
    JOIN products p ON od.product_id = p.product_id
    WHERE od.order_id = o.order_id
    LIMIT 1
) AS first_product_name
FROM orders o;
```

在这个例子中，我们使用了子查询来获取每个订单的第一个产品的名称，而不是直接JOIN `products`表。这样，我们就减少了JOIN的数量，但需要注意的是，子查询在某些情况下可能不如JOIN高效，因此需要根据实际情况进行权衡。

**使用临时表**：

如果经常需要进行涉及多个表的复杂查询，并且这些查询的某些部分可以重用，那么可以考虑使用临时表来存储中间结果，从而减少JOIN的数量。不过，这也增加了数据库操作的复杂性，并且需要额外管理临时表的生命周期。

### 联合索引失效

联合索引在多种情况下可能不起效。以下是一些常见的例子和情况，说明为什么联合索引可能不会被使用：

1. **查询条件没有使用索引的最左前缀**：
   假设有联合索引 `a.b.c`，如果查询条件只涉及 `b` 或 `c`，而没有涉及 `a`，那么索引可能不会被使用。例如：
   
   ```sql
   SELECT * FROM table WHERE b = 'value';
   ```
   在这个例子中，由于查询条件没有包含索引的最左列 `a`，联合索引可能不会被使用。
   
2. **查询条件中使用了函数或表达式**：
   如果查询条件对联合索引的列使用了函数或表达式，这通常会导致索引失效。例如：
   ```sql
   SELECT * FROM table WHERE YEAR(a) = 2023 AND b = 'value';
   ```
   这里对 `a` 列使用了 `YEAR()` 函数，即使 `a` 是联合索引的一部分，索引也可能不会被使用。

3. **数据类型不匹配**：
   如果查询条件中的数据类型与联合索引列的数据类型不匹配，索引可能不会被使用。例如：
   
   ```sql
   SELECT * FROM table WHERE a = '123'; -- 假设a是整数类型
   ```
   如果 `a` 列是整数类型，而查询条件中使用了字符串，这会导致隐式类型转换，从而使索引失效。
   
4. **使用了OR条件**：
   当查询条件中使用OR连接多个条件，并且这些条件不是基于相同的索引列时，联合索引可能不会被充分利用。例如：
   ```sql
   SELECT * FROM table WHERE a = 'value1' OR c = 'value2';
   ```
   这里 `a` 和 `c` 是联合索引 `a.b.c` 的不同列，使用OR连接它们可能导致索引不被使用或只部分使用。

5. **查询条件中的列顺序与索引顺序不一致**：
   虽然某些数据库优化器能够调整查询条件中的列顺序以匹配索引，但这并不总是发生。如果查询条件中的列顺序与联合索引的顺序不一致，并且优化器没有重新排序它们，那么索引可能不会被使用。例如：
   
   ```sql
   SELECT * FROM table WHERE b = 'value' AND a = 'value2'; -- 索引是a.b.c
   ```
   在这个例子中，尽管 `a` 和 `b` 都是索引的一部分，但由于它们的顺序与索引中的顺序不一致，索引可能不会被充分利用。
   
6. **使用了LIKE查询且通配符在最前面**：
   当使用LIKE查询时，如果通配符 `%` 位于搜索模式的开头，那么索引通常不会被使用。例如：
   
   ```sql
   SELECT * FROM table WHERE a LIKE '%value';
   ```
   这里 `%` 在 `value` 的前面，导致索引失效，因为数据库无法有效地使用索引来定位以任意字符开头的值。
   
7. **索引选择性低**：
   如果索引的选择性很低，即索引列中的不同值的比例很低，数据库优化器可能会认为全表扫描比使用索引更快，从而选择不使用索引。
