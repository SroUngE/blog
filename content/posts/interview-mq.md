---
title: "Interview MQ"
date: 2024-04-02T21:38:36+08:00
draft: true
---



### 消息队列的优缺点

#### 优点

1. **异步**：消息队列允许生产者发送消息后立即继续执行，而不必等待消费者的响应。这种异步通信方式提高了系统的吞吐量和响应速度，使得生产者和消费者可以并行处理任务，提高了系统的整体效率。
2. **解耦**：消息队列将生产者和消费者解耦，使得它们可以独立扩展和维护。这种解耦降低了系统的复杂性，使得各个组件可以更加灵活地进行升级、扩展和修改，而不会对其他组件产生直接的影响。
3. **削峰填谷**：消息队列可以平滑处理流量峰值，避免系统因瞬时压力而崩溃。当系统面临大量的请求时，消息队列可以缓存这些请求，然后逐步地传递给消费者进行处理，从而保证了系统的稳定性和可靠性。

#### 缺点

1. **系统的可用性降低**：消息队列是整个系统通信的核心组件，一旦消息队列服务出现故障，所有依赖于它的系统都可能受到影响，甚至导致整个系统崩溃。
2. **系统复杂性增加**：引入消息队列后，系统的整体架构和组件间的交互变得更为复杂。需要考虑的问题包括消息的发送、接收、处理、确认、重试等，以及如何处理消息的顺序、重复、丢失等问题。
3. **一致性问题**：当多个系统或服务通过消息队列进行交互时，可能会出现数据一致性问题。例如，一个系统成功发送了消息，但另一个系统处理失败，此时需要确保数据的一致性和完整性。

### Kafka、RabbitMQ

**设计理念与用途**：

- **Kafka**：主要面向大规模、高吞吐量的实时数据处理场景，如日志聚合和流处理。
- **RabbitMQ**：更通用，适用于各种消息传递场景，如任务队列、发布/订阅等。

**性能与吞吐量**：

- **Kafka**：在处理大规模数据流时，性能优越，吞吐量极高。
- **RabbitMQ**：性能良好，但在超大规模数据处理上可能不及Kafka。

**持久性与可靠性**：

- 两者都支持消息持久化，确保消息的可靠性。
- **Kafka**：通过副本机制提供更强的容错能力。

**使用与部署**：

- **Kafka**：部署和管理相对复杂，适合大型、复杂的数据处理场景。
- **RabbitMQ**：使用简单，部署直观，适合快速构建消息传递系统。

### RabbitMQ 保证消息的可靠性传输

1. 生产者端的数据丢失处理：

   **使用事务功能**：当生产者发送数据时，可以开启RabbitMQ的事务功能。在发送消息前开启事务，如果消息没有成功被RabbitMQ接收到，生产者会收到异常报错，此时可以回滚事务并重试发送消息。但请注意，开启事务可能会降低性能，因为事务操作通常是同步阻塞的。

   **采用confirm模式**：RabbitMQ提供了confirm模式，生产者可以在发送消息前开启此模式。每个被投递到channel的消息都会分配一个唯一ID标识。当消息写入RabbitMQ后，RabbitMQ会回传一个ack消息给生产者，包含消息的唯一ID标识，从而确认消息被准确收到。如果RabbitMQ没能处理消息，会回传一个nack消息，生产者可以据此进行消息重发。

2. 消费者端的数据丢失处理：

   **使用ack机制**：消费者在处理消息时，应确保在消息成功处理后才发送ack确认。关闭RabbitMQ的自动ack，可以确保在消费者进程挂掉或重启时，RabbitMQ不会错误地认为消息已经被消费，从而避免数据丢失。

3. RabbitMQ服务的数据丢失处理：

   **持久化存储**：将**队列**和**消息**都设置为持久化，这样即使RabbitMQ服务器重启，数据也不会丢失。

   **死信队列**：设置死信队列来处理无法被正常消费的消息。当消息处理失败达到最大重试次数后，可以将消息发送到死信队列中，以便后续处理。



### 避免消息重复投递或重复消费

在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付 ID、订单 ID、帖子 ID 等）作为去重的依据，避免同一条消息被重复消费。



### 消息传输

由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ **使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制**。



### 如何保证消息的顺序性

一个队列只有一个消费者的情况下才能保证顺序，否则只能通过全局ID实现（每条消息都一个msgId，关联的消息拥有一个parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息）
