---
title: "Interview MQ"
date: 2024-04-02T21:38:36+08:00
draft: true
---



### 消息队列的优缺点

#### 优点

1. **异步**：消息队列允许生产者发送消息后立即继续执行，而不必等待消费者的响应。这种异步通信方式提高了系统的吞吐量和响应速度，使得生产者和消费者可以并行处理任务，提高了系统的整体效率。
2. **解耦**：消息队列将生产者和消费者解耦，使得它们可以独立扩展和维护。这种解耦降低了系统的复杂性，使得各个组件可以更加灵活地进行升级、扩展和修改，而不会对其他组件产生直接的影响。
3. **削峰填谷**：消息队列可以平滑处理流量峰值，避免系统因瞬时压力而崩溃。当系统面临大量的请求时，消息队列可以缓存这些请求，然后逐步地传递给消费者进行处理，从而保证了系统的稳定性和可靠性。

#### 缺点

1. **系统的可用性降低**：消息队列是整个系统通信的核心组件，一旦消息队列服务出现故障，所有依赖于它的系统都可能受到影响，甚至导致整个系统崩溃。
2. **系统复杂性增加**：引入消息队列后，系统的整体架构和组件间的交互变得更为复杂。需要考虑的问题包括消息的发送、接收、处理、确认、重试等，以及如何处理消息的顺序、重复、丢失等问题。
3. **一致性问题**：当多个系统或服务通过消息队列进行交互时，可能会出现数据一致性问题。例如，一个系统成功发送了消息，但另一个系统处理失败，此时需要确保数据的一致性和完整性。

### Kafka、RabbitMQ

**设计理念与用途**：

- **Kafka**：主要面向大规模、高吞吐量的实时数据处理场景，如日志聚合和流处理。
- **RabbitMQ**：更通用，适用于各种消息传递场景，如任务队列、发布/订阅等。

**性能与吞吐量**：

- **Kafka**：在处理大规模数据流时，性能优越，吞吐量极高。
- **RabbitMQ**：性能良好，但在超大规模数据处理上可能不及Kafka。

**持久性与可靠性**：

- 两者都支持消息持久化，确保消息的可靠性。
- **Kafka**：通过副本机制提供更强的容错能力。

**使用与部署**：

- **Kafka**：部署和管理相对复杂，适合大型、复杂的数据处理场景。
- **RabbitMQ**：使用简单，部署直观，适合快速构建消息传递系统。



### 生产者可靠性

1. 生产者重连：连接 MQ 失败重试，生产者重试，该重试机制是同步的，并发要求高的项目建议禁用。

2. 生产者确认：RabbitMQ 有 Publisher Confirm 和 Publisher Return 两种确认机制。 开启确认机制后，在 MQ 成功受到消息后会返回确认消息给生产者。返回结果有以下几种情况：

   1. 消息投递到了 MQ，但路由失败。此时会通过 Publisher Return 返回路由异常原因，然后返回 ACK。
   2. 临时消息投递到了 MQ，并且入队成功，返回 ACK。
   3. 持久消息投递到 MQ，并且入队且持久化成功，返回 ACK。
   4. 其他消息都会返回 NACK。

   publisher-confirm-type 有三种模式可选：

   - none: 关闭 confirm 机制

   - simple: 同步阻塞等待 MQ 的回执消息

   - correlated: MQ 异步回调方式返回回执消息（最常用）



### 消息传输方式

由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ **使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制**。



### 保证消息的可靠性传输

即如何确定消息是被成功发送，成功处理了的。通过消息确认机制，主要包括生产者发送确认和消费者接收确认。

1. 生产者确认：

   **开启confirm 模式（异步，推荐）**：将 channel 设置为 confirm 模式，每个被投递到 channel 的消息都会被分配一个唯一ID标识。当消息写入RabbitMQ后，RabbitMQ会回传一个ack消息给生产者，包含消息的唯一ID标识，从而确认消息被准确收到。如果RabbitMQ没能处理消息，会回传一个 nack 消息，生产者通过回调方法来处理该确认消息。

   但如果生产者一直接收不到这个 ack 怎么办？比如消费者处理时间太长或者网络超时。生产者与消费者之间应该约定一个超时时间，比如 5 分钟，对于超出这个时间没有得到响应的消息，可以设置一个定时重发的补偿机制：通过消息落库 + 定时任务来实现。

   **开启事务功能（同步，不推荐）**：当生产者发送数据时，可以开启RabbitMQ的事务功能。在发送消息前开启事务，如果消息没有成功被RabbitMQ接收到，生产者会收到异常报错，此时可以回滚事务并重试发送消息。但请注意，开启事务可能会降低性能，因为事务操作通常是同步阻塞的。

2. 消费者端确认：

   **采用手动 ACK 模式**：消费者确保在消息成功处理后才发送ack确认。自动确认会在消息发送给消费者后立即确认，因此存在丢失消息的可能。关闭自动确认，可以确保在消费者进程挂掉或重启时，RabbitMQ不会错误地认为消息已经被消费，从而避免数据丢失。



### 保证消息不被重复消费（幂等性）

幂等性简单来说就是： 重复调用多次产生的业务结果与调用一次产生的业务结果相同 ；

RabbitMQ 是无法判断消息是否是重复的，因此要保证MQ的幂等性，就要保证消费者不会重复消费相同的消息。

我们可以通过**全局唯一 ID**来保证消息的幂等性，如下：

1. 消费者获取到消息后先根据这个全局 **唯一 ID** 去查询 Redis / DB 是否存在该消息；
2. 如果不存在，则正常消费，消费完毕后写入 Redis / DB；
3. 如果存在，则证明消息被消费过，直接丢弃，不做处理。

Redis 设计：消费者拿到消息后，使用 setnx 命令，将 ID 作为key。若返回1，则说明消息不存在；若返回0，则说明消息存在。



### 保证消息的顺序性

一个队列只有一个消费者的情况下才能保证顺序，核心思路就是根据业务数据关键值划分成多个消息集合，而且每个消息集合中的消息数据都是有序的，每个消息集合有自己独立的一个消费者。否则只能通过全局ID实现（每条消息都一个msgId，关联的消息拥有一个parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息）



### 消息堆积问题

消息堆积是由于生产者发送消息的速度远大于消费者消费消息的速度，解决的思路有两个：一个是增加消费者，让一个队列绑定多个消费者；第二个则是优化消费者的消费速度，如采用异步线程处理等
