---
title: "Interview Project"
date: 2024-05-13
draft: true
---

### 风险场景分析系统

所用技术：Spring + MongoDB + Redis + RabbitMQ + Docker+ Spring Cloud Gateway  

项目描述：该系统是一个带有场景分析功能的风险管理工具，通过定义和模拟多种市场情景，实时计算和分析风险指标，帮助金融机构识别、评估和管理不同的风险，提供决策支持。 

工作描述： 

1. 参与系统的需求实现，架构设计、技术选型、环境搭建以及部分开发工作；
2. 负责优化 MongoDB  查询，使用索引策略，聚合管道技术和分页技术，将系统的查询性能提升了30%；
3.  负责搭建并维护 Redis  集群，以解决高并发场景下的数据缓存和读写性能问题，提升了系统的响应速度；
4. 担任 Scrum Master  的角色，协助团队成功完成敏捷转型，帮助团队成长；

#### 介绍项目

这个项目是风险管理的一部分，更专注于场景分析功能。场景分析允许用户定义和模拟不同的市场情景，包括市场波动、信用风险增加等，以帮助机构评估其在这些情景下的资本需求、风险暴露，通过这种场景分析，金融机构可以更好地理解和管理在不同市场环境下的风险水平，从而做出更明智的决策。

#### 核心功能

- **场景设置**：允许用户定义和配置各种市场风险测试场景，包括股市波动、汇率变动、利率上升等。
- **模拟执行**：执行设定的测试场景，监测资产组合和风险指标在不同市场条件下的表现。
- **结果分析**：分析结果，提供关键的风险指标和报告，帮助机构做出风险管理和资产配置决策。



#### 项目的应用场景？

我们的项目主要应用于金融机构内部的风险管理部门。它用于评估和管理信用（或市场）风险的压力测试场景，帮助机构了解在不同压力条件下可能面临的风险，以制定相应的风险管理策略和资产配置决策。



#### 是实时的系统？还是定期出报告？
我们的系统可以支持实时模拟和定期报告生成两种模式。实时模拟用于即时评估当前市场情景下的风险表现，而定期报告则用于基于历史数据或预设情景进行定期的风险评估和报告生成。



#### 系统会产出哪些数据？
系统会产出包括但不限于以下数据：

- 不同条件下的风险指标，如资产价值、违约率、风险敞口等。
- 场景测试的结果和分析报告，包括关键的风险指标、潜在的风险暴露、资产配置建议等。



#### 系统研究的对象是什么？
系统研究的对象是金融机构的资产组合或信用组合，在不同市场环境或压力条件下的表现和风险暴露程度。



#### 系统的流程？
系统的流程通常包括以下步骤：

- 场景设置：用户定义和配置不同的压力测试场景和参数。
- 模拟执行：系统根据设定的场景执行压力测试模拟，生成数据并分析结果。
- 结果分析：系统将模拟结果转化为可视化报告或数据指标，供风险管理团队参考和决策。



#### 系统会需要接收不同的输入？调用上游的输入怎么兼容不同的数据源？
是的，系统需要接收不同的输入，包括市场数据、信用数据、利率数据等。为了兼容不同的数据源，我们采用灵活的数据接口和数据格式处理技术，能够从多个数据源中获取数据，并进行数据清洗、转换和整合，确保系统能够准确地进行分析，不受数据来源的限制。



#### 系统怎么接收不同的输入？

1. **数据接口抽象和设计**：
   - 我们采用了面向接口的设计原则，定义了灵活的数据接口，以支持从不同数据源中获取数据。这些接口可以包括数据获取、数据处理和数据转换等功能。

2. **数据格式标准化**：
   - 我们制定了统一的数据格式标准，例如JSON或XML，作为数据交换的通用格式。这样可以确保不同数据源提供的数据在接收和处理过程中具有一致的数据结构和格式。

3. **适配器模式的应用**：
   - 我们使用了适配器模式来处理不同数据源之间的差异。通过编写适配器类，我们可以将不同数据源的数据转换成统一的内部数据结构，从而使系统能够统一处理不同格式和来源的数据。

4. **动态配置和参数化**：

   - 我们设计了灵活的配置机制，允许用户动态地配置数据源连接参数和数据处理规则。这样可以适应不同环境和不同需求，保证系统的灵活性和扩展性。

   

#### 你能简单描述一下该风险场景管理系统的整体架构吗？

该风险场景管理系统的整体架构采用了 **微服务架构** 风格。

​	**1. 前端层**：前端采用了React。前后端通信是 RESTful 风格的。

​	**2. 后端层**：后端包含了多个微服务，每个微服务负责处理特定的业务逻辑。例如，有负责风险计算的服务、报告生成的服务等。

​	**3. 数据层**：数据库主要使用了MongoDB作为主数据库，存储风险场景、指标、报告等结构化数据。同时还引入了Redis作为缓存层，缓存热点数据和中间结果。

​	**4. 基础设施层**：整个系统部署在云平台上，利用Docker容器化技术实现轻量级部署和快速扩展。通过Docker Compose或Kubernetes等工具进行容器编排和管理，确保系统的稳定性和高可用性。



- 在项目中最困难的技术问题是什么？你是如何解决的？

我遇到的最困难的技术问题是优化一个复杂的金融市场风险场景的查询。这个查询涉及多个集合的数据关联、大量的聚合计算以及实时数据的搜索。由于数据量大、计算复杂，原始的查询逻辑导致查询性能低下，无法满足系统实时性的要求。

具体来说，这个查询需要分析多种金融市场风险场景，包括股票、债券、衍生品等多种金融产品的价格、波动率、相关性等数据。这些数据分布在不同的MongoDB集合中，需要进行复杂的聚合计算来生成风险指标。同时，由于金融市场数据是实时更新的，查询还需要考虑实时数据的筛选和更新。

为了解决这个问题，我采取了以下措施：

1. **索引策略优化**：使用`explain()`方法查看查询的执行计划，查看 `winningPlan` 里是索引扫描还是全集合扫描，确定了哪些字段需要建立索引，以及索引的类型和顺序。此外，通过查看`executionStats`中的`totalKeysExamined`和`totalDocsExamined`字段来判断索引的效率。`totalKeysExamined`表示扫描的索引条目数，而`totalDocsExamined`表示扫描的文档数。如果`totalDocsExamined`的值远大于`totalKeysExamined`，那么可能索引不够有效，需要进一步优化。通过合理设计索引，我成功提高了查询的性能和响应速度。
2. **聚合管道优化**：针对聚合计算的复杂性，我利用MongoDB的聚合管道技术进行了优化。我通过精心设计聚合阶段，将多个聚合操作合并成一个管道，减少了数据库操作的次数。同时，我还利用聚合管道中的 `$match` 阶段进行了数据的预筛选，减少了不必要的计算。
3. **分页技术应用**：由于查询结果数据量很大，我引入了分页技术来分批次返回结果，避免了单次查询返回大量数据导致的性能问题。一开始使用的是聚合的方式 `skip()`，`sort()`，`limit()`，但是后来发现在数据量很大的情况下`skip()`的效率很慢，所以我就改成了用游标 `cursor` 的方式。
4. **并行计算与分布式处理**：基于上面的优化，我采用了并行计算和分布式处理的策略。我利用多个计算节点并行执行查询任务，将计算任务分散到不同的节点上，从而提高了整体的计算能力和查询性能。
5. **缓存策略**：为了进一步提高查询性能，我还引入了缓存策略。我利用Redis集群缓存了部分计算结果和数据，当相同的查询再次发生时，可以直接从缓存中获取结果，避免了重复计算和数据库查询。

通过以上的优化措施，我成功地解决了这个复杂查询的性能问题。查询速度得到了显著提升，满足了系统实时性的要求。这个经验让我更加深入地理解了MongoDB的查询优化技术，并积累了宝贵的实践经验。同时，我也学会了如何在复杂场景下灵活运用不同的技术手段来解决实际问题，为团队的成功做出了贡献。



### Rate Limit

情景：项目是单机的，需要调用下游的API来获取数据，下游有API调用次数限制，每秒最多调用10次

任务：设计一套 流量控制 的方案

行动：常见的 流量控制 算法有漏桶算法和令牌桶算法，

1. 漏桶算法：漏桶算法描述了一个固定容量的漏桶，请求来了直接放桶里，按照常量固定速率流出水滴。如果桶是空的，则不需流出水滴；如果桶是满的，则流入的水滴会溢出（拒绝服务）。
2. 令牌桶算法：令牌桶算法以恒定的速率往桶中放入令牌，桶满则停止放入令牌；当请求到达时，会尝试从桶中取出一个令牌，如果拿到则继续处理请求，如果拿不到则拒绝服务。

这两个算法的主要区别是是否考虑请求到来的速度。令牌桶算法可以应对突发流量，因为它允许桶里面积累令牌，而漏桶算法则不能。所以最终选择了由Google Guava 的Rate Limiter 实现的令牌桶算法。在每次发送请求之前获取令牌，成功则调用，失败的话，实现了一个基于指数退避的重试机制，来避免频繁的无效请求。超过重试次数的话，就会失败，转到失败处理机制。整个流程都做了监控和警报，跟踪请求的拒绝率、请求的相应时间等指标。

结果：实现效果保证了调用 下游 API的可靠性。

Rate Limiter

RateLimiter 实际上并不直接暴露桶的容量设置（这是由内部实现管理的），但我们可以设置和调整令牌的生成速率。桶的“容量”实际上是动态管理的，它基于令牌的生成速率和请求到达的速率。如果请求到达的速率远低于令牌生成的速率，那么桶中的令牌数量会增长（但不会无限增长，因为内部会有一定的限制）。如果请求到达的速率接近或超过令牌生成的速率，桶中的令牌数量将保持稳定或下降。通过允许桶中积累一定数量的令牌来实现的，允许它在短时间内处理超过其稳定速率的请求。

如果你有一个分布式系统，你可能需要考虑使用像Redis这样的外部存储来跟踪和限制请求速率。在那种情况下，你可以使用Redis的Lua脚本来原子地执行速率限制逻辑，或者使用像`resilience4j`或`Sentinel`这样的库来提供分布式环境下的速率限制功能。

