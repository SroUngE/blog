---
title: "Interview Redis"
description: "基于 ChatGPT3.5，回答常见的 Redis 面试题。"
date: 2024-01-25
tags: ["Redis"]
featuredImage: "https://s2.loli.net/2024/01/23/FdJWU6IpNZGfACv.png"
featuredImagePreview: "https://s2.loli.net/2024/01/23/FdJWU6IpNZGfACv.png"
draft: false
---

<!--more-->

### Redis 介绍

#### 介绍

Redis，英文全称是 **Remote Dictionary Server**（远程字典服务），是一个开源的内存 Key-Value 存储系统，常用于缓存、会话管理和消息队列。它支持多种数据结构如字符串、哈希、列表等，具有**快速读写**和**持久化**的特性，适合处理大规模的数据和高并发访问。

#### 优点

* 高性能，得益于其基于内存的特性，使其能够迅速读写数据。
* 灵活性，灵活的数据模型和丰富的数据结构支持，使得开发者可以选择最适合其需求的存储方式，提高了应用的灵活性。
* 可持久性，允许在需要时将数据保存到磁盘，保证数据不会因意外丢失。

#### 缺点

* 内存限制，由于 Redis 将所有数据存储在内存中，不适合用作海量数据的高性能读写。
* 高并发性能限制，单线程处理命令意味着在某些高并发情况下可能出现性能瓶颈。



### Redis 的数据结构类型

Redis支持多种数据结构类型，包括

1. String（字符串）：存储文本或二进制数据。
2. Hash（哈希）：将多个键值对组织在一起，常用于存储对象。
3. List（列表）：双向链表，支持从两端添加和弹出元素，可用于实现队列、栈等数据结构。
4. Set（集合）：无序且唯一的元素集合，支持集合间的交、并、差运算。
5. zset（有序集合）：类似集合，但每个元素关联一个分数，可用于实现排行榜等功能。



### Redis 的高性能

Redis具有高性能的原因主要包括以下几点：

1. **基于内存：** Redis将数据存储在内存中，相比于从磁盘读取数据，内存访问速度更快，提高了读写性能。

2. **单线程模型：** Redis采用单线程模型处理命令，通过避免线程切换的开销，简化了并发控制，从而提高了性能。虽然是单线程，但通过非阻塞的I/O和事件驱动的方式，Redis仍能有效地处理并发请求。

3. **高效的数据结构：** Redis支持多种数据结构，如哈希表、跳跃表等，这些数据结构的设计和实现都经过优化，提高了读写操作的效率。

4. **非阻塞的 I/O 操作：** Redis使用了非阻塞的I/O操作，可以在等待数据从磁盘加载或网络传输时执行其他操作，充分利用了系统资源。

5. **事件驱动：** Redis采用事件驱动的方式处理命令，通过异步非阻塞的事件循环，能够高效地响应输入事件，提高了系统的响应速度。



### 缓存穿透，缓存雪崩，缓存击穿

**缓存穿透（Cache Penetration）** 

缓存穿透是指查询一个根本不存在的数据，由于缓存没有命中，请求直接传递到数据库，导致无谓的查询操作。攻击者可通过构造恶意的请求，不断请求不存在的缓存数据，使得系统每次都要去查询数据库，从而消耗资源。

**解决方法** 

- 可以在查询结果为空时，仍然将空结果进行缓存，但设置较短的过期时间，避免频繁查询数据库。
- 使用布隆过滤器等机制，过滤掉不存在的数据的请求。



**缓存雪崩（Cache Avalanche）** 

缓存雪崩指的是缓存中大量的缓存数据在同一时间失效，导致大量的请求直接击穿到底层存储系统，造成系统瞬时压力激增，可能导致系统崩溃。这通常是由于缓存数据设置了相同的过期时间，一旦过期，大量的请求落在同一时刻。

**解决方法** 

- 设置不同的过期时间，使缓存数据的失效时间分散开来，防止同时失效。
- 采用缓存预热策略，提前加载热点数据，降低缓存失效的风险。使用多个缓存节点，避免单点故障。



**缓存击穿（Hotspot Invalid）**

缓存击穿指的是缓存某个热门或频繁请求的缓存键过期后，恰好此时有大量请求同时涌入，导致有大量请求直达数据库，增加了数据库的负载。

**解决方法** 

- 使用互斥锁（Mutex Lock）或分布式锁来保护对数据库的访问，防止多个线程同时访问数据库。
- 使用热点数据永不过期的策略，或者采用预先加载的方式，确保热点数据始终在缓存中。



### Redis 的过期策略

Redis 采用两种主要的过期策略来管理 Key 的过期：

1. **定时过期（Timed Expiry）：** Redis使用定时器（timer）来检测 Key 是否过期。每个 Key 都会设置一个过期时间（TTL，Time To Live），当 Key 的过期时间到达时，定时器会删除这个 Key 。这样，定时删除机制确保过期的 Key 在一定时间内被及时删除。

2. **惰性过期（Lazy Expiry）：** 在访问 Key 时才检查它是否过期，过期则删除。这样的机制在实际应用中能够更好地利用系统资源，因为不是所有 Key 都会被及时访问。

这两种过期策略的结合使用，使得Redis能够高效地处理过期的 Key 。在定时删除中，Redis会每隔100ms就随机检查一定数量的Key 是否过期，以及是否需要删除。同时采用惰性删除，当访问某个 Key 时，Redis会检查该 Key 是否过期，如果过期则删除。这两者结合起来确保了过期 Key 能够及时被删除，同时避免了频繁的定时器检查，提高了性能。



### Redis 的内存淘汰策略

当内存达到上限时，可以通过设置 `maxmemory-policy` 参数来指定Redis的内存淘汰策略。以下是几种具体的内存淘汰策略：

1. `noeviction`：默认策略，当内存达到上限时，写入操作将会报错，不会删除任何数据。

2. `allkeys-lru`：Redis会从所有键中选择最近最少使用的键进行淘汰。

3. `allkeys-lfu`：Redis会从所有键中选择最不经常使用的键进行淘汰。

4. `allkeys-random`：Redis会从所有键中随机选择一个进行淘汰。

5. `volatile-lru`：Redis会从设置了过期时间的键中选择最近最少使用的键进行淘汰。

6. `volatile-lfu`：Redis会从设置了过期时间的键中选择最不经常使用的键进行淘汰。

7. `volatile-random`：Redis会从设置了过期时间的键中随机选择一个进行淘汰。

8. `volatile-ttl`：Redis会从设置了过期时间的键中，选择剩余时间最短的键进行淘汰。

这些策略可以根据系统的特定需求进行配置。例如，如果希望优先保留设置了过期时间的键，可以选择带有`volatile`前缀的策略。



### Redis 的常见应用场景

1. **缓存管理：** 使用Redis缓存热点数据，减轻数据库负担，提高响应速度。
2. **会话管理：** 存储用户会话数据，实现分布式Session管理（不同服务器同个Session），确保用户登录状态的一致性。
3. **消息队列：** 通过Redis的发布/订阅机制，实现异步消息通信，提高系统解耦性。
4. **分布式锁：** 利用Redis的原子性操作 `setnx` ，实现分布式环境下的锁机制，保证数据一致性。
5. **计数器：** Redis自带计数器功能，非常适合用于统计网站访数据，高效实现原子递增和递减操作。
6. **实时排行榜：** 利用有序集合 `zset` 存储分数和成员，实现实时排名功能，如用户积分排行。
7. **位操作：** 使用Redis的位操作可以轻松地表示用户在线状态。每一位可以代表一个用户的在线或离线状态，通过位运算实现高效的在线状态管理。



### Redis 的持久化机制

Redis有两种主要的持久化机制：RDB（Redis DataBase）和AOF（Append Only File）。

1. **RDB持久化**：通过定期将内存中的数据快照保存到磁盘上的二进制文件，它是Redis默认的持久化方式。这种方式适用于大规模的数据恢复场景，如备份和灾难恢复。你可以配置Redis定期创建RDB快照，也可以手动触发。RDB没办法做到实时持久化/秒级持久化。

2. **AOF持久化**：将每个写操作追加到一个文件中，以记录所有执行的命令，默认是不开启的。这种方式更加持久，因为即使在发生故障时，只要AOF文件没有损坏，Redis可以通过重新执行AOF文件中的命令来恢复数据。AOF记录的内容越多，文件越大，数据恢复变慢。

可以同时使用RDB和AOF，也可以选择只使用其中一种。配置这些机制的方式在Redis的配置文件中进行，例如，你可以通过`save`配置项来设置RDB的触发条件，而通过`appendonly`配置项来启用AOF。

需要注意的是，AOF和RDB可以同时启用，但在恢复时，AOF的优先级更高。如果启用了AOF，Redis将首先尝试使用AOF文件进行恢复，如果AOF文件不存在或不完整，则尝试使用RDB文件。
